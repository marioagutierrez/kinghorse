---
// Three.js Background Component (Client-side only)
---

<div id="three-canvas" class="absolute inset-0 z-10"></div>

<script>
    import * as THREE from "three";

    // Wait for DOM to be ready
    if (typeof window !== "undefined") {
        const canvas = document.getElementById("three-canvas");
        if (!canvas) throw new Error("Canvas not found");

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000,
        );
        const renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
        });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        canvas.appendChild(renderer.domElement);

        camera.position.z = 5;

        // Particle system
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 1500;

        const posArray = new Float32Array(particlesCount * 3);
        const velocities = new Float32Array(particlesCount * 3);

        for (let i = 0; i < particlesCount * 3; i += 3) {
            // Position
            posArray[i] = (Math.random() - 0.5) * 20;
            posArray[i + 1] = (Math.random() - 0.5) * 20;
            posArray[i + 2] = (Math.random() - 0.5) * 20;

            // Velocity (speed of particles)
            velocities[i] = (Math.random() - 0.5) * 0.02;
            velocities[i + 1] = (Math.random() - 0.5) * 0.01;
            velocities[i + 2] = (Math.random() - 0.5) * 0.02;
        }

        particlesGeometry.setAttribute(
            "position",
            new THREE.BufferAttribute(posArray, 3),
        );

        // Material with golden color
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.05,
            color: 0xd4af37, // Gold
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
        });

        const particlesMesh = new THREE.Points(
            particlesGeometry,
            particlesMaterial,
        );
        scene.add(particlesMesh);

        // Animation
        let mouseX = 0;
        let mouseY = 0;

        document.addEventListener("mousemove", (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        const animate = () => {
            requestAnimationFrame(animate);

            // Update particle positions
            const positions = particlesGeometry.attributes.position
                .array as Float32Array;

            for (let i = 0; i < particlesCount * 3; i += 3) {
                // Move particles
                positions[i] += velocities[i];
                positions[i + 1] += velocities[i + 1];
                positions[i + 2] += velocities[i + 2];

                // Reset particles that go out of bounds
                if (Math.abs(positions[i]) > 10) positions[i] = -positions[i];
                if (Math.abs(positions[i + 1]) > 10)
                    positions[i + 1] = -positions[i + 1];
                if (Math.abs(positions[i + 2]) > 10)
                    positions[i + 2] = -positions[i + 2];
            }

            particlesGeometry.attributes.position.needsUpdate = true;

            // Rotate based on mouse position
            particlesMesh.rotation.y = mouseX * 0.5;
            particlesMesh.rotation.x = mouseY * 0.5;

            renderer.render(scene, camera);
        };

        animate();

        // Handle window resize
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }
</script>

<style>
    #three-canvas {
        pointer-events: none;
    }

    #three-canvas canvas {
        display: block;
    }
</style>
